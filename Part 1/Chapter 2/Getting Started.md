# Chapter 2 Getting Started

## 2.1 插入排序

1. 假设前面 $i$ 个数字已经排序完成。
2. 第 $i+1$ 个数字（将其称为 **key**）从原来排好的 $i$ 个数字的末尾开始比较。如果 key 小于第 $j,(j\le i)$ 个数字，则将第 $j$ 个数字放入第 $j+1$ 位；如果不小于（大于等于），则将 key 放入第 $j+1$ 位。比较至数组开头为止。

```python
for i in range(len(a) - 1):
    key = a[i + 1]
    for j in range(i, -1, -1):
        if a[j + 1] < a[j]:
            a[j + 1] = a[j]
        else:
            a[j] = key
            break
```

## 2.2 循环不变式

每次插入前的前面 $i$ 个数字为循环不变式。

### 三条性质

初始化：循环的第一次迭代之前，它为真。

保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。

（上两条类似数学归纳法。）

终止：在循环终止时，不变式可以提供一个性质帮助我们验证该算法是正确的。

（终止迭代。）

## 2.3 归并排序

**分解**：分解待排序的 $n$ 个元素的序列成各具 $n/2$ 个元素的两个子序列。

**解决**：使用归并排序递归地排序两个子序列。

**合并**：合并两个已排序的子序列以产生已排序的答案。

1. 将数字分成大小相近的两堆，不断细分。
2. 对于两堆比较的数字，比较最前面的数字，然后由小到大排序，形成排序好的一堆。不断返回。

## 2.4 分治法

**分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例。

**解决**这些子问题，递归地求解各子问题。

**合并**这些子问题的解成原问题的解。