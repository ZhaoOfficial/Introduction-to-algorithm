# Chapter 6 Heap Sort

## 6.1 堆 Heap

堆是一个数组，可以被看成一个完全二叉树。给定一个下标，我们可以用左移右移得到父节点和左右孩子的下标。

堆分为最大堆和最小堆，最大堆的每个节点中的值不小于其两个子节点的值。最小堆则相反。

## 6.2 维护堆的性质

给定一个下标，该节点的值不满足堆的性质，故我们需要逐层下降，恢复堆的性质。

在每一步中， 我们从一个节点 A 和它的两个子节点中选出满足堆性质的极值，如果节点 A 是这样的极值，那么结束。否则，某个子节点是这样的极值，交换 A 和这个孩子。递归调用直到结束。

时间复杂度：

寻找最大值，交换的时间复杂度是 $\Theta(1)$ ，在子树上递归调用时，子树的大小至多为原来的 $2/3$，故递归式为：
$$
T(n)\le T(2n/3)+\Theta(1)
$$
解得 $T(n)=O(\log n)$。

## 6.3 建堆

对于一个长度为 $n$ 的堆（数组下标从$1\to n$），其中下标为 $\lfloor n/2\rfloor + 1\to n$ 都是叶节点，故只需对前面的节点进行维护即可。即 Floyd 算法。

由于含 $n$ 个元素的堆高度为 $\lfloor\log n\rfloor$，高度为 $h$ 的节点最多有 $n/2^{h+1}$ 个。
$$
\sum_{h=0}^{\lfloor\log n\rfloor}\lceil\frac{n}{2^{h+1}}\rceil O(h)=
O(n\sum_{h=0}^{\lfloor\log n\rfloor}\lceil\frac{h}{2^{h+1}}\rceil)=
O(n\sum_{h=0}^{\infty}\lceil\frac{h}{2^{h+1}}\rceil)=O(n)
$$
故建堆的时间复杂度为 $O(n)$。

## 6.4 堆排序 heap sort

每次把堆顶元素取出，再维护堆，取出的顺序或倒序即为所需的数组排序。

取出时间复杂度为 $O(n)$，维护 $n$ 次，每次 $\log n$ 的时间，故时间复杂度为 $O(n\log n)$。

## 6.5 优先队列 priority queue

堆是实现优先队列的一种方法。