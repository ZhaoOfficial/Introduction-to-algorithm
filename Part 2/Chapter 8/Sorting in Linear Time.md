# Chapter 8 Sorting in Linear Time

## 8.1 比较排序的下界

在排序的最终结果中，各元素的次序依赖于它们之间的比较，我们把这类排序算法称为比较排序。

假设输入的元素都是互异的，那么只需要 $\le$ 或 $>$ 即可进行排序。

比较排序可以被抽象为一棵决策树。决策树是一棵完全二叉树，表示在给定输入规模的情况下，某一特定排序算法对所有元素的比较操作。每个结点表示 $a_i$ 和 $a_j$ 之间的比较，左子树表示 $a_i\le a_j$ 的情况，右子树表示 $a_i>a_j$ 的情况。如果到达了叶节点，表示从根到该叶节点的顺序都已经确定了。对于一个正确的排序算法，应该把 $n!$ 种情况全部表示出来，故路径长度等于树的高度等于 $\Omega(\log n!)=\Omega(n\log n)$。

## 8.2 计数排序 Counting Sort

假设 $n$ 个输入元素均为 $0\thicksim k$ 的整数，当 $k=O(n)$ 时，计数排序的时间复杂度为 $\Theta(n)$ 。

基本原理是，如果有 $n$ 个元素小于 $x$，那么 $x$ 应该被放在第 $n$ 个位置（从 $0$ 开始）。

故使用一个数组记录，其中 $C[i]$ 表示小于 $i$ 元素的个数。那么就可以把元素放在应该放的位置了。通过倒序排列对重复元素进行了更好的处理。

计数排序是稳定的 stable ，在原数组中位置靠后的元素必然在新数组的位置的最后。

## 8.3 基数排序 Radix Sort

基数排序从最低位到最高位使用稳定的排序算法进行排序。

对于一个 $k$ 进制的数，每个数位有 $k$ 个可能取值。如果使用的稳定的排序算法时间复杂度是 $O(n+k)$，那么假设最大的数字有 $d$ 位，则基数排序的时间复杂度是 $O(d(n+k))$。

更一般的来说，给定一个 $b$ 位数和正整数 $r\le b$，如果使用的稳定的排序算法时间复杂度是 $O(n+k)$，那么基数排序的时间复杂度是 $\Theta((b/r)(n+2^r))$。

> 对于一个值 $r\le b$，可以看成 $d=\lceil b/r \rceil$ 个 $r$ 位数。每一个数都是属于 $[0\thicksim 2^r-1]$ 的整数。之后再采用计数排序。例如 $b=32, r=8, d=4, k=255$，总时间就是 $O(4*(n+255))$。

## 8.4 桶排序 Bucket Sort

假设数据满足 $\text{Unif}(0, 1)$。将 $[0,1)$ 划分为 $k$ 个大小相同的子区间，称为桶。然后把数据放入对应的桶中，对于桶中的元素进行排序，再把各个桶中的元素列出来就排序完成了。

初始化和放入桶中时间复杂度是 $\Theta(n)$。

一个桶排序的期望是：
$$
k\cdot O(\frac{n}{k}\log \frac{n}{k})=O(n(\log n-\log k))
$$
当 $k$ 比较大的时候，桶排序变为计数排序，时间复杂度可以到达 $\Theta(n)$。